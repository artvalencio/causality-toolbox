function [cami_xy,cami_yx,mi,diridx,te_xy,te_yx] = cami(x,y,lx,ly,xlinepos,ylinepos,tau)
% CAMI Calculates the Causal Mutual Information (CaMI) for a bivariate time-series
% See Bianco-Martinez, E. and Baptista, M.S. ('Space-time nature of causality', arXiv:1612.05023) 
% for theoretical details
%--------------------------------------------------------
% Version note: in this version partition lines are defined by the user
% and ly_past=lx, with ly_future=ly-ly_past. 
%
% Future releases will provide a method for automatically obtaining the
% optimal partition lines. 
%--------------------------------------------------------
% Known limitations: 
%                 (i) time-series in excess of 10^8 points may experience
%                 issues
%--------------------------------------------------------
% Inputs:
%            x,y:  the time-series, provided as single columns of the data
%                  values, without timestamp.
%           lx,ly: length of the symbolic sequence for analysis in x and y
%                  (e.g.: lx=2 ly=5: blocks of 2 points in variable x and 
%                  5 points in variable y will be analysed. In this case, 
%                  causality is measured considering 2 points of the past
%                  of one time-series, and 2 points of the past and 3 points
%                  of the future of the other time-series.
%           xlinepos,ylinepos: vectors defining the position of the partition
%                  division lines, which defines marginal probabilities.
%           tau: time-delay of the time-Poincare mapping. If time-series is 
%                  already generated by a map, the user should set tau to 1. 
%                  Otherwise, for "continuous time-series" the user should find
%                  the tau leading to minimisation of cross correlation, or 
%                  maximal of mutual information or maximal of CaMI. This 
%                  strategy seeks to create a time-Poincare mapping that will 
%                  behave as a Markov system by the partition chosen (lx,ly). 
%
%--------------------------------------------------------
% Outputs:
%           cami_xy: Causal Mutual Information x -> y
%           cami_yx: Causal Mutual Information y -> x
%           mi:      Mutual Information between x and y,
%                    calculated using symbolic sequences
%                    of length lx in variables x and y. 
%           diridx:  Directionality Index, defined as CaMI(x->y)-CaMI(y->x),
%                    positive if flow of information is x -> y
%           te_xy:   Transfer Entropy x -> y
%           te_yx:   Transfer Entropy y -> x
%
%           if print=1: 
%                  The file "calculations.mat" is generated containing
%                  all marginal and joint probabilities required for the
%                  calculation of CaMI. 
%                  The file "output.txt" is also generated containing a summary
%                  of all results.
%--------------------------------------------------------
% Examples:
%
%     (i)  From Bianco-Martinez, E. and Baptista, M.S. (arXiv:1612.05023):
%
%         [cami_xy,cami_yx,mi,diridx,te_xy,te_yx] = cami(x,y,2,5,0.5,0.5,1,1);
%
%           (In the paper, for x and y time-series from coupled logistic map, 
%            with r=4 and alpha=0.09. This is already saved on "map.csv" file. 
%            Before calling the function on Matlab, import "map.csv" as column 
%            vectors, naming the first column as "x" and the second as "y")
%
%     (ii) A case with 3 initial divisions (not necessarily in same positions), 
%          2 points of past->2points of future, and high lag (tau=8):
%
%         [cami_xy,cami_yx,mi,diridx,te_xy,te_yx] = cami(x,y,2,4,[0.2,0.6],[0.2,0.8],8,1);
%
%--------------------------------------------------------
% (C) Arthur Valencio* and Dr Murilo S. Baptista, 20 Sep 2017
%     ICSMB, University of Aberdeen
%     *Thanks to CNPq scholarship, Brazil

%check consistency
    if length(x)~=length(y)
        error('x and y must be of same size!')
    end
    if length(xlinepos)~=length(ylinepos)
        error('xlinepos and ylinepos must be of same size!')
    end
    ns=length(xlinepos)+1; %partition resolution

%defining numerical precision for calculations
    %numprec=1e-13;

%calculating symbols
    for n=1:length(x) %assign data points to partition symbols in x
        Sx(n)=-1;
        for i=1:length(xlinepos)
            if x(n)<xlinepos(i)
                Sx(n)=i-1;
                break;
            end
        end
        if Sx(n)==-1
            Sx(n)=ns-1;
        end
    end
    for n=1:length(y) %assign data points to partition symbols in y
        Sy(n)=-1;
        for i=1:length(ylinepos)
            if y(n)<ylinepos(i)
                Sy(n)=i-1;
                break;
            end
        end
        if Sy(n)==-1
            Sy(n)=ns-1;
        end
    end
    
    [p_xp,p_yp,p_yf,p_ypf,p_xyp,p_xypf,phi_x,phi_yp,phi_yf]=getprobabilities(Sx,Sy,lx,ly,ns,tau,length(x));
    
    %Calculating mutual information
    mi=0;
    for i=1:ns^lx
        for j=1:ns^lx
            if (p_xp(i)*p_yp(j)>0)&&(p_xyp(i,j)>0)
                mi=mi+p_xyp(i,j)*log(p_xyp(i,j)/(p_xp(i)*p_yp(j)));
            end
        end
    end
    
    %Calculating CaMI X->Y
    cami_xy=0;
    for i=1:ns^lx
        for j=1:ns^lx
            for k=1:1:ns^(ly-lx)
                if (p_xp(i)*p_ypf(j,k)>0) && (p_xypf(i,j,k)>0)
                    cami_xy=cami_xy+p_xypf(i,j,k)*log(p_xypf(i,j,k)/(p_xp(i)*p_ypf(j,k)));
                end
            end
        end
    end
    
    %Calculating CaMI Y->X
    [ip_x,ip_yp,ip_yf,ip_ypf,ip_xyp,ip_xypf,iphi_x,iphi_yp,iphi_yf]=getprobabilities(Sy,Sx,lx,ly,ns,tau,length(x));
    cami_yx=0;
    for i=1:ns^lx
        for j=1:ns^lx
            for k=1:1:ns^(ly-lx)
                if (ip_x(i)*ip_ypf(j,k)>0)&&(ip_xypf(i,j,k)>0)
                    cami_yx=cami_yx+ip_xypf(i,j,k)*log(ip_xypf(i,j,k)/(ip_x(i)*ip_ypf(j,k)));
                end
            end
        end
    end
    
    %Obtaining remaining outputs
    diridx=cami_xy-cami_yx;
    te_xy=cami_xy-mi;
    te_yx=cami_yx-mi;
    
end

%%
function [p_xp,p_yp,p_yf,p_ypf,p_xyp,p_xypf,phi_x,phi_yp,phi_yf]=getprobabilities(Sx,Sy,lx,ly,ns,tau,len)
% calculates the values of phi and probabilities used for CaMI and mutual information

    %initializing phi: removing points out-of-reach (start-end)
    phi_x(1:tau*lx)=NaN;
    phi_yp(1:tau*lx)=NaN;
    phi_yf(1:tau*lx)=NaN;
    %phi_ypf(1:tau*lx)=NaN;
    %phi_xyp(1:tau*lx)=NaN;
    %phi_xypf(1:tau*lx)=NaN;
    phi_x(len-tau*(ly-lx):len)=NaN;
    phi_yp(len-tau*(ly-lx):len)=NaN;
    phi_yf(len-tau*(ly-lx):len)=NaN;
    %phi_ypf(len-tau*(ly-lx):len)=NaN;
    %phi_xyp(len-tau*(ly-lx):len)=NaN;
    %phi_xypf(len-tau*(ly-lx):len)=NaN;
    %initializing probabilities of boxes
    %nopoints=len-tau*ly-1;
    p_xp(1:ns^lx+1)=0;
    p_yp(1:ns^lx+1)=0;
    p_yf(1:ns^(ly-lx)+1)=0;
    p_ypf(1:ns^lx+1,1:ns^(ly-lx)+1)=0;
    p_xyp(1:ns^lx+1,1:ns^lx+1)=0;
    p_xypf(1:ns^lx+1,1:ns^lx+1,1:1:ns^(ly-lx)+1)=0;
    %calculating phi_x, about the past of x
    for n=tau*lx+1:len-tau*(ly-lx)
        phi_x(n)=0;
        k=n-lx;%running index for sum over tau-spaced elements
        for i=n-tau*lx:tau:n-tau
            phi_x(n)=phi_x(n)+Sx(k)*ns^((n-1)-k);
            k=k+1;
        end
        p_xp(phi_x(n)+1)=p_xp(phi_x(n)+1)+1;
    end
    p_xp=p_xp/sum(p_xp);
    %calculating phi_yp, about the past of y
    for n=tau*lx+1:len-tau*(ly-lx)
        phi_yp(n)=0;
        k=n-lx;
        for i=n-tau*lx:tau:n-tau
            phi_yp(n)=phi_yp(n)+Sy(k)*ns^((n-1)-k);
            k=k+1;
        end
        p_yp(phi_yp(n)+1)=p_yp(phi_yp(n)+1)+1;
    end
    p_yp=p_yp/sum(p_yp);
    %calculating phi_yf, about the future of y
    for n=tau*lx+1:len-tau*(ly-lx)
        phi_yf(n)=0;
        k=n;
        for i=n:tau:n+tau*(ly-lx)-1
            phi_yf(n)=phi_yf(n)+Sy(k)*ns^((n+(ly-lx)-1)-k);%%
            k=k+1;
        end
        p_yf(phi_yf(n)+1)=p_yf(phi_yf(n)+1)+1;
    end
    p_yf=p_yf/sum(p_yf);
    %calculating joint probabilities
    for n=tau*lx+1:len-tau*(ly-lx)
        p_ypf(phi_yp(n)+1,phi_yf(n)+1)=p_ypf(phi_yp(n)+1,phi_yf(n)+1)+1;
        p_xyp(phi_x(n)+1,phi_yp(n)+1)=p_xyp(phi_x(n)+1,phi_yp(n)+1)+1;
        p_xypf(phi_x(n)+1,phi_yp(n)+1,phi_yf(n)+1)=p_xypf(phi_x(n)+1,phi_yp(n)+1,phi_yf(n)+1)+1;
    end
    p_ypf=p_ypf/sum(sum(p_ypf));
    p_xyp=p_xyp/sum(sum(p_xyp));
    p_xypf=p_xypf/sum(sum(sum(p_xypf)));
end
function [cami_xy,cami_yx,mutual_info,diridx,te_xy,te_yx,pointwise] = cami(x,y,L_past,L_fut,xpart,ypart,tau,units,varargin)
% CAMI Calculates the Causal Mutual Information (CaMI) for a bivariate time-series
% For some theoretical details, see:
% Bianco-Martinez, E. and Baptista, M.S. ('Space-time nature of causality', arXiv:1612.05023)
%--------------------------------------------------------
% Inputs:
%           x,y:  the time-series, provided as single columns of the data
%                  values, without timestamp.
%           L_past,L_fut: length of the symbolic sequence for analysis.
%                  (e.g.: L_past=3 L_fut=2: the analysis considers if 
%                   a historic of 3 points in the variables x and y is
%                   causally related to 2 points of the future of y).
%           xpart,ypart: vectors defining the position where the partition
%                  division lines are located. 
%                  (e.g.: x_part=[0.5,1] means that points of x<0.5 are 
%                  symbolic encoded as '0', between 0.5 and 1 are encoded 
%                  as '1', and x>1 are encoded as '2')
%           tau: time-delay of the time-Poincare mapping. If time-series is 
%                  already generated by a map, the user should set tau to 1. 
%                  Otherwise, for "continuous time-series" the user should find
%                  the tau leading to minimisation of cross correlation, or 
%                  maximal of mutual information or maximal of CaMI. This 
%                  strategy seeks to create a time-Poincare mapping that will 
%                  behave as a Markov system by the partition chosen (lx,ly).
%           units: 'bits' for log in base 2, 'nats' for log in base e. In
%                  case of typos, bits are assumed as standard.
%           varargin: options:
%               'save': to save the outputs to a file.
%               'delay', followed by value (integer): to add a delay between x and y.
%                        (e.g. delay,7: gives a delay of 7 time-series
%                        points between x and y, i.e., evaluates if x causes
%                        y considering that y might have delayed response of
%                        7 time units. Value can be negative too, for studies of
%                        phenomena similar to anticipated synchronization)
%               'local', followed by value (positive integer): to calulate measures 
%                        over a sliding rectangular window
%                        (e.g. 'local',10000: gives the measures calculated 
%                        over a sliding window of 10000 points) 
%--------------------------------------------------------
% Outputs:
%           cami_xy: Causal Mutual Information x -> y
%           cami_yx: Causal Mutual Information y -> x
%           mutual_info:      Mutual Information between x and y,
%                    calculated using symbolic sequences
%                    of length lx in variables x and y. 
%           diridx:  Directionality Index, defined as CaMI(x->y)-CaMI(y->x),
%                    positive if flow of information is x -> y
%           te_xy:   Transfer Entropy x -> y
%           te_yx:   Transfer Entropy y -> x
%           pointwise: Struct with pointwise information measures
%
%           if 'save': 
%                  The file "calculations.mat" is generated containing
%                  all marginal and joint probabilities required for the
%                  calculation of CaMI. 
%                  The file "output.txt" is also generated containing a summary
%                  of all results.
%--------------------------------------------------------
% Examples:
%
%     (i)  Case on Bianco-Martinez, E. and Baptista, M.S. (arXiv:1612.05023):
%
%         [cami_xy,cami_yx,mi,diridx,te_xy,te_yx,pointwise] = cami(x,y,2,3,0.5,0.5,1,'nats');
%
%           (In the paper x and y are time-series from coupled logistic maps, 
%            with r=4 and alpha=0.09)
%
%     (ii) A case with 3 initial divisions (not necessarily in same positions), 
%          2 points of past->2points of future, and high lag (tau=8):
%
%         [cami_xy,cami_yx,mi,diridx,te_xy,te_yx] = cami(x,y,2,2,[0.2,0.6],[0.2,0.8],8,'bits');
%
%--------------------------------------------------------
% (C) Arthur Valencio* and Dr Murilo S. Baptista, version update: 16 May 2018
%     ICSMB, University of Aberdeen
%     *Support: CNPq (Brazil) [206246/2014-5]   


%Below is the preamble. For the important parts, go to 'main' function.

    lx=L_past;
    ly=L_past+L_fut;

    %options
    print=0;
    delay=0;
    islocal=0;
    windowsize=0;
    if nargin>8
        for i=1:size(varargin)
                if strcmp(varargin{i},'save')
                    print=1;
                end
                if strcmp(varargin{i},'delay')
                    delay=varargin{i+1};
                end
                if strcmp(varargin{i},'local')
                    islocal=1;
                    windowsize=varargin{i+1};
                end
        end
    end

    %check input consistency
    if length(x)~=length(y)
        error('x and y must be of same size!')
    end
    if length(xpart)~=length(ypart)
        error('xlinepos and ylinepos must be of same size!')
    end
    ns=length(xpart)+1; %partition resolution

    %adjusting if delayed option
    if delay~=0
        if delay>0
            y=y(1:length(x)-delay);
            x=x(1:length(y));
        elseif delay<0
            x=x(1:length(y)+delay);
            y=y(1:length(x));
        end
    end
       
    if islocal   %Calculates for sliding window case ('local' measures)
        t=1;
        while 1
            xwindow=x(t:t+windowsize);
            ywindow=y(t:t+windowsize);
            [cami_xy(t),cami_yx(t),mutual_info(t),diridx(t),te_xy(t),te_yx(t),pointwise{t}] = main(xwindow,ywindow,lx,ly,xpart,ypart,tau,units,ns,print);
            if t+windowsize==length(x)
                break;
            end
            t=t+1;
        end
    else %Calculation over the whole time-series ('global' measures)
        [cami_xy,cami_yx,mutual_info,diridx,te_xy,te_yx,pointwise] = main(x,y,lx,ly,xpart,ypart,tau,units,ns,print);
    end
    
end

function [cami_xy,cami_yx,mutual_info,diridx,te_xy,te_yx,pointwise] = main(x,y,lx,ly,xpart,ypart,tau,units,ns,print)
    
    %calculating symbols
    for n=1:length(x) %assign data points to partition symbols in x
        Sx(n)=-1;
        for i=1:length(xpart)
            if x(n)<xpart(i)
                Sx(n)=i-1;
                break;
            end
        end
        if Sx(n)==-1
            Sx(n)=ns-1;
        end
    end
    for n=1:length(y) %assign data points to partition symbols in y
        Sy(n)=-1;
        for i=1:length(ypart)
            if y(n)<ypart(i)
                Sy(n)=i-1;
                break;
            end
        end
        if Sy(n)==-1
            Sy(n)=ns-1;
        end
    end
    
    [p_xp,p_yp,p_yf,p_ypf,p_xyp,p_xypf,phi_x,phi_yp,phi_yf]=getprobabilities(Sx,Sy,lx,ly,ns,tau,length(x));
        
    %Calculating mutual information
    mutual_info=0;
    for i=1:ns^lx
        for j=1:ns^lx
            if (p_xp(i)*p_yp(j)>1e-14)&&(p_xyp(i,j)>1e-14)
                pmi(i,j)=p_xyp(i,j)*log(p_xyp(i,j)/(p_xp(i)*p_yp(j)));
                mutual_info=mutual_info+pmi(i,j);
            else
                pmi(i,j)=0;
            end
        end
    end
    
    %Calculating CaMI X->Y
    cami_xy=0;
    for i=1:ns^lx
        for j=1:ns^lx
            for k=1:1:ns^(ly-lx)
                if (p_xp(i)*p_ypf(j,k)>1e-14) && (p_xypf(i,j,k)>1e-14)
                    pcami_xy(i,j,k)=p_xypf(i,j,k)*log(p_xypf(i,j,k)/(p_xp(i)*p_ypf(j,k)));
                    cami_xy=cami_xy+pcami_xy(i,j,k);
                else
                    pcami_xy(i,j,k)=0;
                end
            end
        end
    end
    
    %Calculating CaMI Y->X
    [ip_x,ip_yp,ip_yf,ip_ypf,ip_xyp,ip_xypf,iphi_x,iphi_yp,iphi_yf]=getprobabilities(Sy,Sx,lx,ly,ns,tau,length(x));
    cami_yx=0;
    for i=1:ns^lx
        for j=1:ns^lx
            for k=1:1:ns^(ly-lx)
                if (ip_x(i)*ip_ypf(j,k)>1e-14)&&(ip_xypf(i,j,k)>1e-14)
                    pcami_yx(i,j,k)=ip_xypf(i,j,k)*log(ip_xypf(i,j,k)/(ip_x(i)*ip_ypf(j,k)));
                    cami_yx=cami_yx+pcami_yx(i,j,k);
                else
                    pcami_yx(i,j,k)=0;
                end
            end
        end
    end
    
    %Adjusting units
    if strcmp(units,'nats')==0
        mutual_info=mutual_info/log(2);
        cami_xy=cami_xy/log(2);
        cami_yx=cami_yx/log(2);
        pmi=pmi/log(2);
        pcami_xy=pcami_xy/log(2);
        pcami_yx=pcami_yx/log(2);
    end

    %Obtaining remaining outputs
    diridx=cami_xy-cami_yx;
    te_xy=cami_xy-mutual_info;
    te_yx=cami_yx-mutual_info;
    
    %Generating struct of pointwise informational measures
    pointwise.pmi=pmi;
    pointwise.pcami_xy=pcami_xy;
    pointwise.pcami_yx=pcami_yx;
    pointwise.pdiridx=pcami_xy-pcami_yx;
    pointwise.pte_xy=pcami_xy-pmi;
    pointwise.pte_yx=pcami_yx-pmi;
    
    %print calculations to file
    if print
        timeseries=table;
        timeseries.x=x;
        timeseries.y=y;
        timeseries.Sx=Sx';
        timeseries.Sy=Sy';
        timeseries.phi_x=phi_x';
        timeseries.phi_yp=phi_yp';
        timeseries.phi_yf=phi_yf';
        timeseries.inv_phi_y=iphi_x';
        timeseries.inv_phi_xp=iphi_yp';
        timeseries.inv_phi_xf=iphi_yf';
        writetable(timeseries);
        dlmwrite('output.txt','CaMI calculation','delimiter','');
        dlmwrite('output.txt','-----------------------------------','delimiter','','-append');
        dlmwrite('output.txt','Selected parameters by the user:','delimiter','','-append');
        dlmwrite('output.txt',strcat('- Number of symbols (ns): ',num2str(ns)),'delimiter','','-append');
        dlmwrite('output.txt',strcat('- Length of symbolic sequence in x (lx): ',num2str(lx)),'delimiter','','-append');
        dlmwrite('output.txt',strcat('- Length of symbolic sequence in y (ly): ',num2str(ly)),'delimiter','','-append');
        dlmwrite('output.txt','- Position of partition delimiter lines:','-append','delimiter','');
        dlmwrite('output.txt','* in x: ','-append','delimiter','');
        dlmwrite('output.txt',xpart,'delimiter','\t','precision',5,'-append')
        dlmwrite('output.txt','* in y: ','-append','delimiter','');
        dlmwrite('output.txt',ypart,'delimiter','\t','precision',5,'-append')
        dlmwrite('output.txt','-----------------------------------','delimiter','','-append');
        dlmwrite('output.txt','Output:','delimiter','','-append');
        dlmwrite('output.txt',strcat('- CaMI X->Y: ',num2str(cami_xy)),'delimiter','','-append');
        dlmwrite('output.txt',strcat('- CaMI Y->X: ',num2str(cami_yx)),'delimiter','','-append');
        dlmwrite('output.txt',strcat('- Directionality Index (CaMI_{X->Y} - CaMI_{Y->X}): ',num2str(diridx)),'delimiter','','-append');
        dlmwrite('output.txt',strcat('- Mutual Information of X and Y: ',num2str(mutual_info)),'delimiter','','-append');
        dlmwrite('output.txt',strcat('- Transfer Entropy X->Y: ',num2str(te_xy)),'delimiter','','-append');
        dlmwrite('output.txt',strcat('- Transfer Entropy Y->X: ',num2str(te_yx)),'delimiter','','-append');
        dlmwrite('output.txt','-----------------------------------','delimiter','','-append');
        dlmwrite('output.txt','**Probability boxes and timeseries can be seen in calculations.mat**','delimiter','','-append');
        dlmwrite('output.txt','**Timeseries and box assignment can also be seen in timeseries.txt**','delimiter','','-append');
        dlmwrite('output.txt','-----------------------------------','delimiter','','-append');
        dlmwrite('output.txt','(C) Arthur Valencio* and Murilo S. Baptista, 2017-2018','delimiter','','-append');
        dlmwrite('output.txt','ICSMB, University of Aberdeen','delimiter','','-append');
        dlmwrite('output.txt','*Thanks to CNPq scholarship, Brazil','delimiter','','-append');
        initialparameters=table;
        initialparameters.resolution=ns;
        initialparameters.symbol_x_length=lx;
        initialparameters.symbol_y_length=ly;
        save('calculations.mat','timeseries','initialparameters','cami_xy',...
            'cami_yx','diridx','mi','te_xy','te_yx','p_xp','p_yp','p_yf','p_ypf',...
            'p_xyp','p_xypf','ip_x','ip_yp','ip_yf','ip_ypf','ip_xyp','ip_xypf')
    end
end


function [p_xp,p_yp,p_yf,p_ypf,p_xyp,p_xypf,phi_x,phi_yp,phi_yf]=getprobabilities(Sx,Sy,lx,ly,ns,tau,len)
% calculates the values of phi and probabilities used for CaMI and mutual information

    %initializing phi: removing points out-of-reach (start-end)
    phi_x(1:tau*lx)=NaN;
    phi_yp(1:tau*lx)=NaN;
    phi_yf(1:tau*lx)=NaN;
    %phi_ypf(1:tau*lx)=NaN;
    %phi_xyp(1:tau*lx)=NaN;
    %phi_xypf(1:tau*lx)=NaN;
    phi_x(len-tau*(ly-lx):len)=NaN;
    phi_yp(len-tau*(ly-lx):len)=NaN;
    phi_yf(len-tau*(ly-lx):len)=NaN;
    %phi_ypf(len-tau*(ly-lx):len)=NaN;
    %phi_xyp(len-tau*(ly-lx):len)=NaN;
    %phi_xypf(len-tau*(ly-lx):len)=NaN;
    %initializing probabilities of boxes
    %nopoints=len-tau*ly-1;
    p_xp(1:ns^lx+1)=0;
    p_yp(1:ns^lx+1)=0;
    p_yf(1:ns^(ly-lx)+1)=0;
    p_ypf(1:ns^lx+1,1:ns^(ly-lx)+1)=0;
    p_xyp(1:ns^lx+1,1:ns^lx+1)=0;
    p_xypf(1:ns^lx+1,1:ns^lx+1,1:1:ns^(ly-lx)+1)=0;
    %calculating phi_x, about the past of x
    for n=tau*lx+1:len-tau*(ly-lx)
        phi_x(n)=0;
        k=n-lx;%running index for sum over tau-spaced elements
        for i=n-tau*lx:tau:n-tau
            phi_x(n)=phi_x(n)+Sx(k)*ns^((n-1)-k);
            k=k+1;
        end
        p_xp(phi_x(n)+1)=p_xp(phi_x(n)+1)+1;
    end
    p_xp=p_xp/sum(p_xp);
    %calculating phi_yp, about the past of y
    for n=tau*lx+1:len-tau*(ly-lx)
        phi_yp(n)=0;
        k=n-lx;
        for i=n-tau*lx:tau:n-tau
            phi_yp(n)=phi_yp(n)+Sy(k)*ns^((n-1)-k);
            k=k+1;
        end
        p_yp(phi_yp(n)+1)=p_yp(phi_yp(n)+1)+1;
    end
    p_yp=p_yp/sum(p_yp);
    %calculating phi_yf, about the future of y
    for n=tau*lx+1:len-tau*(ly-lx)
        phi_yf(n)=0;
        k=n;
        for i=n:tau:n+tau*(ly-lx)-1
            phi_yf(n)=phi_yf(n)+Sy(k)*ns^((n+(ly-lx)-1)-k);%%
            k=k+1;
        end
        p_yf(phi_yf(n)+1)=p_yf(phi_yf(n)+1)+1;
    end
    p_yf=p_yf/sum(p_yf);
    %calculating joint probabilities
    for n=tau*lx+1:len-tau*(ly-lx)
        p_ypf(phi_yp(n)+1,phi_yf(n)+1)=p_ypf(phi_yp(n)+1,phi_yf(n)+1)+1;
        p_xyp(phi_x(n)+1,phi_yp(n)+1)=p_xyp(phi_x(n)+1,phi_yp(n)+1)+1;
        p_xypf(phi_x(n)+1,phi_yp(n)+1,phi_yf(n)+1)=p_xypf(phi_x(n)+1,phi_yp(n)+1,phi_yf(n)+1)+1;
    end
    p_ypf=p_ypf/sum(sum(p_ypf));
    p_xyp=p_xyp/sum(sum(p_xyp));
    p_xypf=p_xypf/sum(sum(sum(p_xypf)));
end

